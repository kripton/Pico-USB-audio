// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// --- //
// pdm //
// --- //

#define pdm_wrap_target 0
#define pdm_wrap 0

static const uint16_t pdm_program_instructions[] = {
  //     .wrap_target
  0x6001,  //  0: out    pins, 1
           //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program pdm_program = {
  .instructions = pdm_program_instructions,
  .length = 1,
  .origin = -1,
};

static inline pio_sm_config pdm_program_get_default_config(uint offset) {
  pio_sm_config c = pio_get_default_sm_config();
  sm_config_set_wrap(&c, offset + pdm_wrap_target, offset + pdm_wrap);
  return c;
}

static inline void pdm_program_init(PIO pio, uint sm, uint offset, uint data_pin, float clk_div) {

  pio_sm_config c = pdm_program_get_default_config(offset);
  sm_config_set_out_pins(&c, data_pin, 1);
  pio_gpio_init(pio, data_pin);
  pio_sm_set_consecutive_pindirs(pio, sm, data_pin, 1, true);
  gpio_set_drive_strength(data_pin,3);
  sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);
  sm_config_set_clkdiv(&c, clk_div);
  sm_config_set_out_shift(&c, true, true, 32);
  pio_sm_init(pio, sm, offset, &c);
  pio_sm_set_enabled(pio, sm, true);
}
uint32_t pdm_4_os32(int16_t sig) {
  // doesn't everyone love magic numbers?
   //int32_t mi = -98304;
  int32_t mi = -65536;
  
  //int32_t ma2 = 196608;
  int32_t ma2 = 131072;
  
  //int32_t ma128 = 12582912;
  int32_t ma128 = 8388608;
  
  //int32_t mi128 = -12582912;
  int32_t mi128 = -8388608;
  
  //int32_t ma2128 = 25165824;
  int32_t ma2128 = 16777216;

  // static to remember values loop to loop
  static int32_t evals[4] = { 0, 0, 0, 0 };
  static int32_t dvals[4] = { 0, 0, 0, 0 };

  // this will hold pdm signal
  uint32_t out = 0;

  int32_t d1 = mi128 - sig * 128;
  int32_t d11 = mi - sig;

  for (int j = 0; j < 32; j++) {

    // the feedback is composed of deltas and errors
    // this could definitely be more efficient and is the bottleneck
    int32_t deltas = -409 * dvals[0] - 273 * dvals[2] + 498 * dvals[1] + 57 * dvals[3];
    int32_t ecmp = (evals[0] + evals[2]) * 4 - 6 * evals[1] - evals[3];
  
    int32_t etmp = d1 + deltas + ecmp;

    // //update values
    evals[3] = evals[2];
    evals[2] = evals[1];
    evals[1] = evals[0];
    evals[0] = etmp;
    dvals[3] = dvals[2];
    dvals[2] = dvals[1];
    dvals[1] = dvals[0];
    dvals[0] = d11;
     
    // tim's secret as to why this works...
    if (etmp <0) {
      evals[0] += ma2128;
      dvals[0] += ma2;
      out += (1 << j);
    }
  }
  return out;
}
static inline void pdm_write32(uint32_t sig, PIO pio, uint sm) {
  while (pio_sm_is_tx_fifo_full(pio, sm)) {}
  pio->txf[sm] = sig;
}

#endif
